<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>X</title>
  
  <subtitle>x</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-26T11:50:43.407Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>X</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sqlite3-SQLite数据库模块简单认识</title>
    <link href="http://yoursite.com/2019/05/26/sqlite3-SQLite%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9D%97%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/"/>
    <id>http://yoursite.com/2019/05/26/sqlite3-SQLite数据库模块简单认识/</id>
    <published>2019-05-26T11:35:07.000Z</published>
    <updated>2019-05-26T11:50:43.407Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>SQLite 是一个C语言库，它可以提供一种轻量级的基于磁盘的数据库，这种数据库不需要独立的服务器进程，也允许需要使用一种非标准的 SQL 查询语言来访问它。一些应用程序可以使用 SQLite 作为内部数据存储。可以用它来创建一个应用程序原型，然后再迁移到更大的数据库，比如 PostgreSQL 或 Oracle。</em></strong><br>要使用这个模块，必须先创建一个 Connection 对象，它代表数据库。下面例子中，数据将存储在 example.db 文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sqlite3</span><br><span class="line">conn = sqlite3.connect(&apos;example.db&apos;)</span><br></pre></td></tr></table></figure></p><p>你也可以使用 :memory: 来创建一个内存中的数据库</p><p>当有了 Connection 对象后，你可以创建一个 Cursor 游标对象，然后调用它的 execute() 方法来执行 SQL 语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">c = conn.cursor()</span><br><span class="line"></span><br><span class="line"># 创建表</span><br><span class="line">c.execute(&apos;&apos;&apos;CREATE TABLE stocks</span><br><span class="line">             (date text, trans text, symbol text, qty real, price real)&apos;&apos;&apos;)</span><br><span class="line"></span><br><span class="line"># 插入一行数据</span><br><span class="line">c.execute(&quot;INSERT INTO stocks VALUES (&apos;2006-01-05&apos;,&apos;BUY&apos;,&apos;RHAT&apos;,100,35.14)&quot;)</span><br><span class="line"></span><br><span class="line"># 保存（提交）更改</span><br><span class="line">conn.commit()</span><br><span class="line"></span><br><span class="line"># 我们也可以在完成任务后，关闭连接</span><br><span class="line"># 只需要保证在关闭之前任何更改都已提交</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure></p><p>这些数据被持久化保存了，而且可以在之后的会话中使用它们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sqlite3</span><br><span class="line">conn = sqlite3.connect(&apos;example.db&apos;)</span><br><span class="line">c = conn.cursor()</span><br></pre></td></tr></table></figure></p><p>通常你的 SQL 操作需要使用一些 Python 变量的值。你不应该使用 Python 的字符串操作来创建你的查询语句，因为那样做不安全；它会使你的程序容易受到 SQL 注入攻击（在 <a href="https://xkcd.com/327/" target="_blank" rel="noopener">https://xkcd.com/327/</a> 上有一个搞笑的例子，看看有什么后果）</p><p>推荐另外一种方法：使用 DB-API 的参数替换。在你的 SQL 语句中，使用 ? 占位符来代替值，然后把对应的值组成的元组做为 execute() 方法的第二个参数。（其他数据库可能会使用不同的占位符，比如 %s 或者 :1）例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Never do this -- insecure!</span><br><span class="line">symbol = &apos;RHAT&apos;</span><br><span class="line">c.execute(&quot;SELECT * FROM stocks WHERE symbol = &apos;%s&apos;&quot; % symbol)</span><br><span class="line"></span><br><span class="line"># Do this instead</span><br><span class="line">t = (&apos;RHAT&apos;,)</span><br><span class="line">c.execute(&apos;SELECT * FROM stocks WHERE symbol=?&apos;, t)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"># Larger example that inserts many records at a time</span><br><span class="line">purchases = [(&apos;2006-03-28&apos;, &apos;BUY&apos;, &apos;IBM&apos;, 1000, 45.00),</span><br><span class="line">             (&apos;2006-04-05&apos;, &apos;BUY&apos;, &apos;MSFT&apos;, 1000, 72.00),</span><br><span class="line">             (&apos;2006-04-06&apos;, &apos;SELL&apos;, &apos;IBM&apos;, 500, 53.00),</span><br><span class="line">            ]</span><br><span class="line">c.executemany(&apos;INSERT INTO stocks VALUES (?,?,?,?,?)&apos;, purchases)</span><br></pre></td></tr></table></figure></p><p>要在执行 SELECT 语句后获取数据，你可以把游标作为 iterator，然后调用它的 fetchone() 方法来获取一条匹配的行，也可以调用 fetchall() 来得到包含多个匹配行的列表。</p><p>下面是一个使用迭代器形式的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for row in c.execute(&apos;SELECT * FROM stocks ORDER BY price&apos;):</span><br><span class="line">        print(row)</span><br><span class="line"></span><br><span class="line">(&apos;2006-01-05&apos;, &apos;BUY&apos;, &apos;RHAT&apos;, 100, 35.14)</span><br><span class="line">(&apos;2006-03-28&apos;, &apos;BUY&apos;, &apos;IBM&apos;, 1000, 45.0)</span><br><span class="line">(&apos;2006-04-06&apos;, &apos;SELL&apos;, &apos;IBM&apos;, 500, 53.0)</span><br><span class="line">(&apos;2006-04-05&apos;, &apos;BUY&apos;, &apos;MSFT&apos;, 1000, 72.0)</span><br></pre></td></tr></table></figure></p><hr><p>摘自Python官方文档</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;SQLite 是一个C语言库，它可以提供一种轻量级的基于磁盘的数据库，这种数据库不需要独立的服务器进程，也允许需要使用一种非标准的 SQL 查询语言来访问它。一些应用程序可以使用 SQLite 作为内部数据存储。可以用它来创建一个应用程序原型，然后再
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浮点的限制与争议</title>
    <link href="http://yoursite.com/2019/05/19/%E6%B5%AE%E7%82%B9%E7%9A%84%E9%99%90%E5%88%B6%E4%B8%8E%E4%BA%89%E8%AE%AE/"/>
    <id>http://yoursite.com/2019/05/19/浮点的限制与争议/</id>
    <published>2019-05-19T04:22:38.000Z</published>
    <updated>2019-05-19T05:21:25.407Z</updated>
    
    <content type="html"><![CDATA[<p>浮点算术在计算机领域的广泛应用不必多说。应该大多数人都有这样的经历，总是在不经意间会遇到浮点运算的一些不满足预期的奇怪输出。这里主要来探讨一下个中奥秘。<br>首先，我们都明白，大多数十进制小数都不能精确地表示为二进制小数，这导致在大多数情况下，你输入的十进制浮点数都只能近似地以二进制浮点数形式储存在计算机中。用十进制来理解这个问题显得更加容易一些。考虑分数$1/3$。我们可以得到它在十进制下的一个近似值$0.3$，或者更接近$0.33$，或者更接近的$0.333……$无论你写下多少，永远只能更接近。同样，我们用$2$作为基数，$0.1$是永远也无法精确表示为二进制的小数。在二进制下，$1/10$是一个无限循环小数$0.0001100110011001100110011001100110011001100110011…$在任何一个位置停下都仅仅只是近似值。因此，在今天的大部分架构上，浮点数都只能近似地使用二进制小数表示，对应分数的分子使用每8字节的前53位表示，分母则表示为$2$的幂次(IEEE754)。在$1/10$这个例子中，相应的二进制分数是 $3602879701896397/2^{55}$ ，它很接近$1/10$，但并不是$1/10$。往往我们能观察到的输出结果精度达不到近似值有差异的地方。记住了，即使输出的结果看起来好像就是$1/10$的精确值，实际储存的值只是最接近$1/10$的计算机可表示的二进制分数。有趣的是，有许多不同的十进制数共享相同的最接近的近似二进制小数。例如，$0.1$、$0.10000000000000001$、$0.1000000000000000055511151231257827021181583404541015625$全都近似于$3602879701896397/2^{55}$。由于所有这些十进制值都具有相同的近似值，因此可以显示其中任何一个。<br>出现浮点运算不符合预期值的情况，其本质不是语言的限制，也不是代码的问题，你在所有支持在硬件中浮点运算的语言都会发现相同的情况。<br>有时我们想要更美观的输出，我们可以对小数进行格式化输出，但其实这并不影响浮点数在计算机里的存储值，只是见舍入后的结果进行显示而已。我们用Python举例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; format(math.pi,&apos;.12g&apos;)</span><br><span class="line">&apos;3.14159265359&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; format(math.pi,&apos;.2f&apos;)</span><br><span class="line">&apos;3.14&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; format(math.pi)</span><br><span class="line">&apos;3.141592653589793&apos;</span><br></pre></td></tr></table></figure></p><p>我们看到的输出结果只是表象而已，不理解内部的运算会在应用过程中产生很多问题。比如下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; .1+.1+.1==.3</span><br><span class="line">Flase</span><br></pre></td></tr></table></figure></p><p>我们无法将$2$为基数的$0.1$精确到十进制的$1/10$，对应的$0.3$同样无法精确。哪怕我们使用Python的$round()$函数预先舍入也无济于事。不过预后舍入就可以达到我们想要的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; round(.1,1)+round(.1,1)+round(.1,1)==round(.3,1)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt;round(.1+.1+.1,10)==round(.3,10)</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p><p>浮点数运算会造成许多这样的“意外”。不过大多数情况下一点误差是可以容忍的。需要注意的是，每次浮点运算都可能导致新的舍入错误。<br>对于需要精确十进制表示的使用场景，请尝试使用$decimal$模块，该模块实现了适合会计应用和高精度应用的十进制运算。<br>另一种形式的精确运算由$fractions$模块提供支持，该模块实现了基于有理数的算术运算（因此可以精确表示像$1/3$这样的数值）。<br>如果你是浮点运算的重度用户，你应该看一下数值运算Python包NumPy以及由SciPy项目所提供的许多其它数学和统计运算包。参见<a href="https://scipy.org" target="_blank" rel="noopener">https://scipy.org</a>。<br>Python也提供了一些工具，可以在你真的想要知道一个浮点数精确值的少数情况下提供帮助。例如float.as_integer_ratio()方法会将浮点数表示为一个分数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x=3.14159</span><br><span class="line">&gt;&gt;&gt; x.as_integer_ratio()</span><br><span class="line">(3537115888337719, 1125899906842624)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; x==3537115888337719/1125899906842624</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p><p>这样的表示法是精确的，可以跨版本移植，和别的标准相同的语言（Java、C99）交换数据。</p><hr><p>这里引出问题所在和基本的解决措施。下一篇将深入本质探讨此问题，包括IEEE754的相关具体细节。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;浮点算术在计算机领域的广泛应用不必多说。应该大多数人都有这样的经历，总是在不经意间会遇到浮点运算的一些不满足预期的奇怪输出。这里主要来探讨一下个中奥秘。&lt;br&gt;首先，我们都明白，大多数十进制小数都不能精确地表示为二进制小数，这导致在大多数情况下，你输入的十进制浮点数都只能近
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法题：爬楼梯</title>
    <link href="http://yoursite.com/2019/05/10/%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%9A%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://yoursite.com/2019/05/10/算法题：爬楼梯/</id>
    <published>2019-05-09T18:29:07.000Z</published>
    <updated>2019-05-10T10:56:12.694Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>题目：假设你正在爬楼梯，需要n阶你才能到达楼顶。每次你可以爬1阶或2阶台阶。你有多少种不同的方法可以爬到楼顶呢？</em></strong></p><hr><p>这里将对此问题写出多个解法，包括一般容易实现的递归，以及它的一步一步优化。</p><hr><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>这是我看到题目后最先想到的也是十分麻烦的方法，但我觉得有必要拿出来看看。思路是，如果爬楼梯每次都选择同一种，即要么全走两阶大致（n的奇偶决定，暂且定为偶数便于理解）一共n/2次到达楼顶，要么全走一阶一共n次就可以到达楼顶。选取其中一种状况进行分析即可，这两种都是终极状态，我需要做的是对两者的相互演化过程做出模拟即可。<br>举个例子，这里优先考虑把选择次数降到最低，每次均走2阶。然后把一个两阶拆成两个1阶，每次拆分选择次数就增加1，再对这一共n/2+1次选择进行排列组合得到一定的方法数，即绝大多数都是走2阶，选择一下在哪几次走一阶，不同的选择是不同的方法。然后再将一个两阶拆分，继续上述操作，直至把所有两阶全部拆分为1阶。这时统计所有方法数即可。这里的代码是上述例子的实现，因为涉及到排列组合，组合数用阶乘计算方便直接，所以又定义了两个子函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int PermuteCombine(int WayNum,int StairsNum)//全部先尽可能多的转化为一次2个台阶的方法，，再将一次2个台阶拆解为两个一次台阶，在在总次数中排列组合。 </span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">if(StairsNum%2==0)//总阶数进行奇偶判断 ，处理大同小异，均从顶向下、以迭代的方法将问题 扩大为一个规模稍大的问题 </span><br><span class="line">for(i=0;i&lt;=StairsNum/2;i++)</span><br><span class="line">WayNum+=C(StairsNum/2+i,StairsNum/2-i);</span><br><span class="line">else</span><br><span class="line">for(i=0;i&lt;(StairsNum+1)/2;i++)</span><br><span class="line">WayNum+=C((StairsNum+1)/2+i,(StairsNum-1)/2-i); </span><br><span class="line">return WayNum;</span><br><span class="line">&#125;</span><br><span class="line">int factorial(int n)//阶乘函数 n！ </span><br><span class="line">&#123;</span><br><span class="line">if(n==1)return 1;//递归出口 </span><br><span class="line">return n*factorial(n-1);</span><br><span class="line">&#125;</span><br><span class="line">int C(int n,int m)//利用数学定义计算组合数 ,n个不同元素中取出m个元素的组合数。用符号 C(n,m) 表示</span><br><span class="line">&#123;</span><br><span class="line">if(m==0||n==m)//特殊情况处理 </span><br><span class="line">return 1;</span><br><span class="line">else</span><br><span class="line">return (factorial(n)/(factorial(n-m)*factorial(m)));//计算公式C(n,m)=n!/[m!*(n-m)!]将结果返回 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不难看出，这里的处理其实是不断地将问题规模扩大，而如果先假定全走1阶，则整个程序体现出来，应该是越来越多的两个一组的1阶被一个二阶取代，问题规模不断变小。其实本质是一样的。</p><blockquote><p>贪心算法（英语：greedy algorithm），又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。不从整体最优上加以考虑，它所做出的是在某种意义上的局部最优解。</p></blockquote><p>这里的方法其实也不是特别符合贪婪的定义，但从某种处理方式上来看具有一定的相似性。贪心算法简单来说两个基本要素，一是贪心选择，而是最优子结构。每做一次贪心选择就将所求问题简化为一个规模更小的子问题。先全走1阶，后一步一步合并成2阶，就是这样一个过程。当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。这里与动态规划十分接近，可以推测此题应该也会有动态规划的解法。<br>    至于贪心的局限在于它在达成整体最优的路上是不可回退的。即在当前选择时，是无法返回上一次选择的状态。</p><h2 id="树形递归模拟爬楼梯"><a href="#树形递归模拟爬楼梯" class="headerlink" title="树形递归模拟爬楼梯"></a>树形递归模拟爬楼梯</h2><p>上一个算法不得不说写的是又烂又长，看的让人头大。这里要介绍的方法理解起来倒是简单多了。看到小标题，相信大家心里已经知道是什么样的了，不多说了，上代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int recursion(int NowNum,int StairsNum)//从0阶台阶开始模拟爬楼梯，构建一个递归树 ，每一层都有两个分支选择，+1或+2。 </span><br><span class="line">&#123;//两个递归出口 </span><br><span class="line">if(NowNum&gt;StairsNum)//上一阶加2后超出总阶数 则此方法无效不计数 </span><br><span class="line">return 0;</span><br><span class="line">if(NowNum==StairsNum)//刚好满足总阶数   则此方法（在递归树中的分支路径）有效记一次 </span><br><span class="line">return 1;</span><br><span class="line">return recursion(NowNum+1,StairsNum)+recursion(NowNum+2,StairsNum);// 将当前方法（路径）继续深化到下一层，直到返回 。上一层方法是下层方法的总和，每层都有两个分支。 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>树形递归，时间复杂度$O(2^n)$，空间树大小$2^n$。</p><h2 id="记忆化递归"><a href="#记忆化递归" class="headerlink" title="记忆化递归"></a>记忆化递归</h2><p>上一个方法倒是简单易懂，但不可避免的浪费了许多空间和时间。其实如果你仔细画过或者模拟过上面的递归树，不难发现一件事，我们有很多重复计算。没有模拟过也不要紧，我们现在大致演示一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                   0</span><br><span class="line">  _________|__________</span><br><span class="line"> |                    |</span><br><span class="line"> 1       2</span><br><span class="line">    _____|_____          _____|_____</span><br><span class="line">   |           |        |           |</span><br><span class="line">   2           3        3           4</span><br><span class="line"> __|__       __|__    __|__       __|__</span><br><span class="line">|     |     |     |  |     |     |     |</span><br><span class="line">3     4     4     5  4     5     5     6</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><p>仔细观察会发现在这个树中，有许多相似的结构分支，尤其是从零开始的分支2，直接包含在分支1中，也就是说，我们深度优先遍历递归树的时候，其实有多于一半的时间和大量空间的浪费都是不必要的。我们只需要用一个数组记录每次的值，当需要递归去计算某个分支时，如果已经计算过则直接从数组中获取值即可，不必再次遍历子树。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//在主函数中要先定义记忆数组，并初始化零。</span><br><span class="line">int memo[StairsNum+1],i;</span><br><span class="line">for(i=0;i&lt;StairsNum+1;i++)//变量定义数组长度后无法直接初始化，定义完后用循环初始化数组。 </span><br><span class="line">memo[i]=0;</span><br><span class="line"></span><br><span class="line">int MemoRecur(int NowNum,int StairsNum,int memo[])// 之前的递归过程有大量的重复计算，改进后把每一步结果都储存下来，以便需要的时候直接使用就不用再次进入递归计算，减少时间，定义数组会占用n大小的空间 </span><br><span class="line">&#123;</span><br><span class="line">if(NowNum&gt;StairsNum)</span><br><span class="line">return 0;</span><br><span class="line">if(NowNum==StairsNum)</span><br><span class="line">return 1;</span><br><span class="line">if(memo[NowNum]&gt;0)</span><br><span class="line">return memo[NowNum];</span><br><span class="line">memo[NowNum]=MemoRecur(NowNum+1,StairsNum,memo)+MemoRecur(NowNum+2,StairsNum,memo);</span><br><span class="line">return memo[NowNum]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>典型的浪费空间换取时间的策略。毫无疑问我们将上一次的算法进行了优化。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>之前的猜测可以证实了，这里确实可以用动态规划，尤其是在上一个优化中，我们发现记忆数组其实帮我完成了一件事——抽象描述就是：使得我们可以在选择时回退到之前选择过的情形而直接获取答案。至于这里使用动态规划的考虑是这样的：如第i阶可由(i-1)阶爬1阶或(i-2)阶爬两阶得到，规划到最初，第三阶由第二阶爬1阶或第1阶爬两阶得到，第四阶是三阶爬1或2阶爬2…类推 。代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int DynamicProgram(int StairsNum)</span><br><span class="line">&#123;</span><br><span class="line">int dp[StairsNum+1],i;</span><br><span class="line">dp[1]=1,dp[2]=2;</span><br><span class="line">for(i=3;i&lt;StairsNum+1;i++)</span><br><span class="line">dp[i]=dp[i-1]+dp[i-2];</span><br><span class="line">return dp[StairsNum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一层循环就结束整个问题，相应，降低了时间，但是用了数组就浪费了空间。</p><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>其实大家应该在之前的某种方法就已经的发现，这道题在数学上就是求斐波那契数列的第N项的值。那么如何求这个数列就变得重要了。也许有人会用递归算，这不免和之前的我们优化过的算法陷入同样的情况，子树会重复，再一步一步优化就到了用一遍循环就算出值。其实对这个数列有所了解的同学应该知道，这个数列是有通项公式的。如下<br>$a_n=\frac{1}{\sqrt 5}[(\frac{1+\sqrt 5}{2})^n-(\frac{1-\sqrt 5}{2})^n]$<br>我们将值代入即可求出对于的通项值，代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int Fib(int StairsNum)//直接使用公式,空间O(1),由于使用POW函数，时间变为O(log n) </span><br><span class="line">&#123;</span><br><span class="line">double s5=sqrt(5);</span><br><span class="line">return(int)(1/s5*(pow((1+s5)/2,StairsNum+1)-pow((1-s5)/2,StairsNum+1)));//可能由于计算精度问题，极少部分答案与准确值相差1， </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于计算次方我们调用了pow()函数，需要导入math.h，无形中我们在计算公式时，还是会消耗一定时间。这时我们的空间复杂度$O(1)$，调用函数缘故，时间复杂度：$O(\log_{}n)$</p><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>借助公式的方法其实不是那么完美，因为有时会有情况限制我们对于函数的使用，那有没有类似的方法可以快速计算出斐波那契数列呢？这里介绍矩阵快速幂。要能使用这方法，我们需要先知道如何用矩阵表示斐波那契数列。<br>我们引入矩阵乘法进行推导：<br>$\left[<br> \begin{matrix}<br>   F_n\\<br>   F_{n-1}<br>  \end{matrix}<br>\right]=<br>\left[<br> \begin{matrix}<br>   F_n+F_{n-2}\\<br>   F_{n-1}<br>  \end{matrix}<br>\right]=<br>\left[<br> \begin{matrix}<br>   1&amp;1\\<br>   1&amp;0<br>  \end{matrix}<br>\right]\cdot<br>\left[<br> \begin{matrix}<br>   F_{n-1}\\<br>   F_{n-2}<br>  \end{matrix}<br>\right]$<br>然后化简：<br>$\left[<br> \begin{matrix}<br>   F_n\\<br>   F_{n-1}<br>  \end{matrix}<br>\right]=<br>\left[<br> \begin{matrix}<br>   1&amp;1\\<br>   1&amp;0<br>  \end{matrix}<br>\right]^{n-1}\cdot<br>\left[<br> \begin{matrix}<br>   1\\<br>   0<br>  \end{matrix}<br>\right]$<br>此时我们知道，想要得出含有斐波那契数列的矩阵，只需要对一个矩阵求幂即可，那么如何能快速求出高次幂变成我们关注的重点。<br>首先由整数快速幂引入。当我们想求$x^8$时，我不必将x自乘8次，而是可以转化为求$x^2$三次，主要是这种结合思想。那用怎样的策略才能把高次拆分成计算最快的低次乘积？我们用$x^{25}$举例子。<br>25的二进制是11001,则$x^{25}=x^{16}\cdot x^8\cdot x^1$，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int QuickPow(int x,int N)</span><br><span class="line">&#123;</span><br><span class="line">    int res = x;</span><br><span class="line">    int ans = 1;</span><br><span class="line">    while(N)</span><br><span class="line">    &#123;</span><br><span class="line">        if(N&amp;1)//位与运算判断N最后一位是否为1</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans * res;</span><br><span class="line">        &#125;</span><br><span class="line">        res = res*res;</span><br><span class="line">        N = N&gt;&gt;1;//位右移，判断下一位</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出res与二进制位权值对应，而ans则负责将我们二进制位上存在1 的进行记录。当N=25时，最终res变成了$x^{32}$，ans变成了$x^{25}$。简单来说就是res一直跑，当遇到我们需要的ans时，在前一次的ans上再乘当前的res。快速幂的处理方法就是这样，这种情形下，我们只使用常量级空间$O(1)$，时间复杂度到了与使用函数一样的$O(\log_{}n)$。我们现在只需要把这种方法放到矩阵中去即可。代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">int QuickPower(int N)</span><br><span class="line">&#123;</span><br><span class="line">int n=2,i,j;</span><br><span class="line">N-=1;//</span><br><span class="line">int ans[2][2],res[2][2],tep[2][2];</span><br><span class="line">for(i=0;i&lt;n;i++)</span><br><span class="line">for(j=0;j&lt;n;j++)//初始化ans矩阵，变成单位矩阵E，进行矩阵乘法的基石 </span><br><span class="line">&#123;</span><br><span class="line">if(i==j)</span><br><span class="line">ans[i][j]=1;</span><br><span class="line">else</span><br><span class="line">ans[i][j]=0;</span><br><span class="line">&#125;</span><br><span class="line">for(i=0;i&lt;n;i++)//初始化res矩阵 </span><br><span class="line">for(j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(i&amp;&amp;j)</span><br><span class="line">res[i][j]=0;</span><br><span class="line">else</span><br><span class="line">res[i][j]=1;</span><br><span class="line">&#125;</span><br><span class="line">while(N)//快速幂部分 </span><br><span class="line">&#123;</span><br><span class="line">if(N&amp;1)</span><br><span class="line">&#123;//ans=ans*res</span><br><span class="line">for(i=0;i&lt;n;i++)</span><br><span class="line">for(j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">tep[i][j]=ans[0][j]*res[i][0]+ans[j][1]*res[1][i];</span><br><span class="line">&#125;</span><br><span class="line">for(i=0;i&lt;n;i++)</span><br><span class="line">for(j=0;j&lt;n;j++)</span><br><span class="line">ans[i][j]=tep[i][j];</span><br><span class="line">&#125;//res=res*res</span><br><span class="line">for(i=0;i&lt;n;i++)</span><br><span class="line">for(j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">tep[i][j]=res[0][j]*res[i][0]+res[j][1]*res[1][i];</span><br><span class="line">&#125;</span><br><span class="line">for(i=0;i&lt;n;i++)</span><br><span class="line">for(j=0;j&lt;n;j++)</span><br><span class="line">res[i][j]=tep[i][j];</span><br><span class="line">N&gt;&gt;=1;</span><br><span class="line">&#125;</span><br><span class="line">return ans[0][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>至此我要介绍的全部方法都结束了。其实，如果认真看下来，可能都有点忘了我们最初只是为了算出爬楼梯的方法数。我之所以要写这么多方法是因为我觉得这些方法远比一道题的最优解重要。因为有些方法可能在这道题里并不是最优的解法，但在别的题里或许是最优的解。我们应该能理解并使用这些方法，哪怕是最开始的贪婪算法，只要掌握了思想，其实在许多地方是有用武之地的。</p><p>总结：爬楼梯问题在本质上来说就是将整体最优解转化为子问题最优解，可选方案包括动态规划与贪心算法，<br>具体到本问题中斐波那契数列的应用以及简化，都是动态规划在此情形下的数学优化，而使用排列组合方法则是贪心算法的体现，如果将问题的特征更一般化，通用的解决方案还得从本质的动态规划和贪心入手，而动态规划相比于贪心则更容易实现，且贪心的每一个操作都会对结果产生直接影响，而动态规划可以把之前的数据保存下来可以回退，数据更立体，可操作性更强。</p><p><em>匆忙总结，如有错误,海涵见谅。</em>😋</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;题目：假设你正在爬楼梯，需要n阶你才能到达楼顶。每次你可以爬1阶或2阶台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这里将对此问题写出多个解法，包括一般容易实现的递归，以及它的一步一步优化。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>异常处理</title>
    <link href="http://yoursite.com/2019/05/07/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/05/07/异常处理/</id>
    <published>2019-05-07T04:13:15.000Z</published>
    <updated>2019-05-07T04:54:07.189Z</updated>
    
    <content type="html"><![CDATA[<p><em>引言：每当人们接触事物时不免产生对其基本概念的哲学思考。也许对人来讲，一句简单的“我是谁？”就足足困扰了哲学家千年，但面对计算机，有些问题却显得容易回答得多了。曾听闻一个观点，研究自然科学是相当困难的，因为对象是自然界，是通过既有的方法与认知对现象进行解读，是在未知中探索；而对于学习一些人们既定的规则也好，生产工具也罢，相对是容易的，因为这些东西都是人类创造产生的，为了提升生产效率等各方面原因，人不必为难自己，一切一定以最易接受和使用为前提。如今想来有些道理，我们有意图所以我们创造，创造工具，构建规则，便利自己。<br>（这篇文章以异常处理为主线讲述，异常这个概念的产生，由何而来，产生的意义，对于它的存在进行探讨。以广义入手，实践落实在 Python3 的应用上 ）</em></p><h2 id="异常是什么？"><a href="#异常是什么？" class="headerlink" title="异常是什么？"></a>异常是什么？</h2><ul><li><strong>标准概念</strong>：异常指的是在程序运行过程中发生的异常事件，通常是由外部问题（如硬件错误、输入错误）所导致的。在Python、Java等面向对象的编程语言中异常属于对象。</li><li><strong>个人理解</strong>：一般来讲异常是个事件，在程序<font color="#DC143C">运行</font>时大多不会被处理，而影响了程序的正常执行。对于程序来讲，其语句或表达式在语法上是正确的，但在尝试执行时，这个事件（异常）会引发错误。这里先入为主地讲，一些面向对象的编程语言将此事件引发的错误抽象成一个对象，亦命名为“异常”，所有异常对象组成一个类。在 Python 中, 所有异常都必须是从 BaseException 派生的类的实例。<blockquote><p><em>更多异常在Python中的细节，建议阅读<a href="https://docs.python.org/3/tutorial/errors.html" target="_blank" rel="noopener">官方文档</a>。需要注意的是，在Python中标准的异常类型是内置的标识符（而不是保留关键字）。<br>（注：大致浏览完文档后，会发现之前先入为主的观点是有些不全面的，为了符合人对于异常的第一印象和某种潜在认知，此前我隐式地将异常与错误等同，其实在Python中，异常不仅仅是以Error作为尾缀的，即有些异常在某种层面上来讲并不是一个错误，而更像是之前讲的，导致程序无法正常执行的事件。）</em></p></blockquote></li></ul><p><strong>说了这么多，异常存在的意义是什么呢？</strong><br>其实是把”程序无法正常进行“这件事更抽象化的集中起来，归为一类。面向对象编程具有更高的整合能力，一个类是具有相同的方法和属性的，这样使我们对于这类事件有了更统一化且流程化的处理方式。这样的处理方式我们称为“异常处理”。</p><h2 id="异常处理是什么？"><a href="#异常处理是什么？" class="headerlink" title="异常处理是什么？"></a>异常处理是什么？</h2><p>上文似乎已经回答了这个问题，但不妨碍我们再深入探究一下。惯例先来一下官方一点的定义<br><em>Wiki：异常处理，是编程语言或计算机硬件里的一种机制，用于处理软件或信息系统中出现的异常状况（即超出程序正常执行流程的某些特殊条件）。</em><br>追根溯源一下，其实在本文讨论的异常处理这种方式出现前，人们对于软硬件不能正常操作时，系统设置了错误代码，即 error code ,对于不同的错误代码有不同的原因导致，操作者可以对其进行识别并找到原因。这样说不够直观，给个例子，比如网页的错误代码  404 ，不用多说相信很多人都见过类似的错误代码。error code 算是异常处理某种意义上的前生，异常处理是代替日渐衰落的error code方法的新法，提供error code 所未能具体的优势。<br><strong>接下来讨论对于编程来讲，这样的处理方式与传统的返回标志配合选择结构有什么区别和优势呢？</strong><br>拿大家应该都熟悉的C语言举例吧，早期我们对于c语言的异常处理机制，通常是我们认为的对返回结果加一些标志来进行判定，如发生错误返回什么标志，正常情况下我们又是返回什么标记，对于不同的标志我们借助选择结构去进行不同的处理，但这些都不是语言本身所赋予我们的，这种机制的问题在于，C语言的异常处理机制全是我们人为的定义，过度的自由往往会导致难以驾驭的混乱产生，如果没有体制化的规则或规范产生，就会造成业务逻辑的主线受到异常处理的牵制，或者说是我们难免会将注意力转移，并且造成业务逻辑与异常处理之间有很大程度上的缠绕。而对于Python来说，它有内部有已经构建好的异常类，我们使用expection的机制，对这些使程序无法正常运行的事件经行捕获和处理，更加方便，使我们有更多的精力专注于业务逻辑，而不必要使主线与异常处理的方式过度耦合而导致难以维护，降低整个系统或程序的灵活性。<br>处理本身的讨论价值已经所剩无多，接下来的应该是这个过程的实现，也就是异常机制。<br><strong>机制问题：</strong></p><ul><li>程序执行方面，大部分常见的程序设计语言，都是沿着函数调用栈的函数调用逆向搜索，直到遇到异常处理代码为止。一般在这个异常处理代码的搜索过程中逐级完成栈卷回。</li><li>语法方面，多数语言的异常机制的语法是类似的：用throw或<font color="#1E90FF">raise</font>抛出一个异常对象（Java或C++等）；异常处理代码的作用范围用标记子句（<font color="#1E90FF">try</font>或begin开始的语言作用域）标示其起始，以第一个异常处理子句（catch,<font color="#1E90FF">expect</font>, resuce等）标示其结束；可连续出现若干个异常处理子句，每个处理特定类型的异常。某些语言允许<font color="#1E90FF">else</font>子句，用于无异常出现的情况。更多见的是<font color="#1E90FF">finally</font>, ensure子句，无论是否出现异常它都将执行，用于释放异常处理所需的一些资源。（蓝色为Python所采用的关键字）</li></ul><p><strong>大致介绍一下Python中关键字的原理</strong><br>由 <font color="#FF8C00">try</font> 讲起，作为处理机制的起始关键词，try的工作原理是如下（引用自<a href="https://docs.python.org/3/tutorial/errors.html" target="_blank" rel="noopener">官方文档</a>）</p><ul><li>首先，执行 try 子句 （try 和 except 关键字之间的（多行）语句）。</li><li>如果没有异常发生，则跳过 except 子句 并完成 try 语句的执行。</li><li>如果在执行try 子句时发生了异常，则跳过该子句中剩下的部分。然后，如果异常的类型和 except 关键字后面的异常匹配，则执行 except 子句 ，然后继续执行 try 语句之后的代码。</li><li>如果发生的异常和 except 子句中指定的异常不匹配，则将其传递到外部的 try 语句中；如果没有找到处理程序，则它是一个 未处理异常，执行将停止并显示如上所示的消息。<blockquote><p>try会控制一个子句，这个子句通常是我们想要测试是否会出现异常的代码段或者会经常出现过多与不可知问题的代码段，try界定了这样的一个范围。</p></blockquote></li></ul><p>与try搭配的就是 <font color="#FF8C00">expect</font> ，那么工作原理：一个 try 语句可能有多个 except 子句，以指定不同异常的处理程序。 最多会执行一个处理程序。 处理程序只处理相应的 try 子句中发生的异常，而不处理同一 try 语句内其他处理程序中的异常。基类的expect语句兼容派生类，反之不然。往往最后的 except 子句可以省略异常名，以用作通配符。</p><blockquote><p>expect的作用浅显易懂，与try搭配起来使用倒也有点 switch-case 的感觉，不过语法更简单，应用更灵活。</p></blockquote><p>主体讲完了，接下来说说可选子句，用做扩充。<br>首先<font color="#FF8C00">else</font>子句，在使用时必须放在所有的 except 子句后面。对于在try 子句不引发异常时必须执行的代码来说很有用。</p><blockquote><p>有时如果不给予通配符，而try语句中的代码出现未能捕获的异常，else的存在就降低了这种情况的出现。</p></blockquote><p><em>至于异常的 <font color="#FF8C00">args</font> 和 <font color="#FF8C00">__str__()</font> ，这里不多赘述。</em><br>抛出异常 <font color="#FF8C00">raise</font> ，有唯一指定参数——异常的实例或类。</p><blockquote><p>问题来了，为什么需要抛出异常呢？有时是对异常进行一定处理后再次扔出，一般的考虑是只想确定是否会抛出异常，或者抛出后还有处理。然而有时候还会和用户自定义异常结合使用，这时候就凸显出其功能。</p></blockquote><p><font color="#FF8C00">用户自定义异常</font>。还记得之前提到过在Python中所有的异常都必须是从 BaseException 派生的类的实例，而这里要强调的是<font color="#1E90FF#DC143C">用户自定义的异常并不是从这个基类直接派生的，而是从 Exception 直接继承或间接继承的，尽管 Exception 是从 BaseException 继承来的。</font><br>最后也就是<font color="#FF8C00">finally</font>，它可以让操作者定义一个清洗行为，finally 子句 总会在离开 try 语句前被执行，无论是否发生了异常。当在 try 子句中发生了异常且尚未被 except 子句处理（或者它发生在 except 或 else 子句中）时，它将在 finally 子句执行后被重新抛出。 当 try 语句的任何其他子句通过 break, continue 或 return 语句离开时，finally 也会在“离开之前”被执行。</p><blockquote><p>在实际应用程序中，finally子句对于释放外部资源（例如文件或者网络连接）非常有用，无论是否成功使用资源。</p></blockquote><p>短暂的介绍只是为了简单回顾和把各个关键词的价值所在指出。</p><h2 id="接下来介绍两种异常处理的基本模型。"><a href="#接下来介绍两种异常处理的基本模型。" class="headerlink" title="接下来介绍两种异常处理的基本模型。"></a>接下来介绍两种异常处理的基本模型。</h2><p><em>第一种为中止模型，另一种为继续模型，或称恢复模型。实际使用方面我们对中止模型用的比较多，这个模型比较实用，而继续模型则不是那么的应用普遍。</em></p><ul><li>中止模型 ：<br>假设错误非常严重，已至你无法在回到错误发生的地方，也就是说，这段程序经过判断认为，他已经没有办法挽回，于是就抛出异常。</li><li><p>继续模型：<br>这种模型的主旨是恢复当前的运行环境，然后希望能够重新回到错误的发生地，并希望第二次的尝试能够获得成功，这种模型通常为操作系统所应用。</p><blockquote><p>虽然恢复模型开始显得很吸引人，并且人们使用的操作系统也支持恢复模型的异常处理,但程序员们最终还是转向了使用类似”终止模型”的代码。因为：处理程序必须关注异常抛出的地点，这势必要包含依赖于抛出位置的非通用性代码。这增加了代码编写和维护的困难，对于异常可能会从许多地方抛出的大型程序来说，更是如此。</p></blockquote><p>完</p></li></ul><hr><p>本文的理想受众不是那些对异常处理毫无认知的人群，而是有初步了解且至少做过一些实践哪怕几行的小程序的这类人，用于更深入的思考和理解一些本质问题，而不是受限于语法句式的细节问题，因而未曾加入代码片段。如需大量代码段，推荐阅读<a href="https://docs.python.org/3/tutorial/errors.html" target="_blank" rel="noopener">官方文档</a>。相比于语法规范和语言特性，本文更集中于思考”定义、概念、存在“的价值，加入了不少主观的感受和理解，如有异议、疑惑欢迎讨论，有错误也欢迎斧正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;引言：每当人们接触事物时不免产生对其基本概念的哲学思考。也许对人来讲，一句简单的“我是谁？”就足足困扰了哲学家千年，但面对计算机，有些问题却显得容易回答得多了。曾听闻一个观点，研究自然科学是相当困难的，因为对象是自然界，是通过既有的方法与认知对现象进行解读，是在未知
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>博客创建问题及解决摘要</title>
    <link href="http://yoursite.com/2019/01/02/%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%91%98%E8%A6%81/"/>
    <id>http://yoursite.com/2019/01/02/博客创建问题及解决摘要/</id>
    <published>2019-01-02T14:56:41.000Z</published>
    <updated>2019-01-02T15:26:19.103Z</updated>
    
    <content type="html"><![CDATA[<p>以下为本博客创建时所遇到的一些疑难问题与所关注过的注意事项，对其有详细解答。中途还会介绍涉及到的部分零碎知识。如有描述不准，望海涵斧正。<a href="https://www.cnblogs.com/fengxiongZz/p/7707219.html" target="_blank" rel="noopener">(参考的安装教程)</a></p><h1 id="一、Node-js-amp-Github环境搭建"><a href="#一、Node-js-amp-Github环境搭建" class="headerlink" title="一、Node.js &amp; Github环境搭建"></a>一、Node.js &amp; Github环境搭建</h1><h5 id="①、下载安装时避免将两个环境置入同一个文件夹"><a href="#①、下载安装时避免将两个环境置入同一个文件夹" class="headerlink" title="①、下载安装时避免将两个环境置入同一个文件夹"></a>①、下载安装时避免将两个环境置入同一个文件夹</h5><h5 id="②、创建Github项目时以“账户名-github-io”为格式"><a href="#②、创建Github项目时以“账户名-github-io”为格式" class="headerlink" title="②、创建Github项目时以“账户名.github.io”为格式"></a>②、创建Github项目时以“账户名.github.io”为格式</h5><h2 id="———————-进入正题———————"><a href="#———————-进入正题———————" class="headerlink" title="———————-进入正题———————-"></a>———————-<em>进入正题</em>———————-</h2><p><del>这里出现问题比较多，需要重点关注</del></p><h1 id="二、安装hexo"><a href="#二、安装hexo" class="headerlink" title="二、安装hexo"></a>二、<strong>安装hexo</strong></h1><h3 id="1、使用npm安装Github"><a href="#1、使用npm安装Github" class="headerlink" title="1、使用npm安装Github"></a>1、使用npm安装Github</h3><p><strong><em>问题Ⅰ：</em></strong>首次用npm安装Github时，一段进度条会一直无法“前进”，安装进度停滞不前。<br><strong>剖析：</strong>首先，简单介绍一下npm。</p><blockquote><p>npm是随同NodeJS一起安装的包(package)管理工具，能解决NodeJS代码部署上的很多问题。<br>它由三个独立的部分组成：</p><ul><li>网站</li><li>注册表(registry)</li><li>命令行工具(CLI)<br>由于众所周知的原因，国内访问外国网站时一直不怎么流畅，就此问题而言，比起搭梯子，一个淘宝镜像来的更方便快捷。:D<br>那么接下来就是讲一下镜像了。<br>镜像是冗余的一种类型，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。<br>根据这个描述，可以知道这个淘宝NPM镜像（可以从网络轻松获得，复制停滞进度条前的代码百度即可）是用来替代官方版本的完整镜像，可以完美解决此问题。<br>附上镜像：<code>npm config set registry https://registry.npm.taobao.org</code>  （退出原有的控制台，再次进入安装hexo的文件夹中，直接在命令行中输入即可）<h3 id="2、关联hexo和Github-page"><a href="#2、关联hexo和Github-page" class="headerlink" title="2、关联hexo和Github page"></a>2、关联hexo和Github page</h3><strong><em>问题Ⅱ：</em></strong><font color="#9932CC"> .ssh </font>文件夹及涉及问题<br><strong>具体描述及解决措施：</strong></li><li>①描述：在Git Bash的命令框中输入<code>cd ~/.ssh</code>时，反馈没有此文件夹。<br>解决方案：正常现象，可以继续教程的下一步，系统会自动创建.ssh文件夹。<br>即输入<code>ssh-keygen -t rsa -C “your email address”</code> <font color="#DC143C">(所有指令中注意空格不可略、不可多)</font><br>然后就没什么多说的了，回车就完事了。这时<font color="#9932CC"> .ssh </font>文件夹中会出现两个文件，一个是公钥一个是私钥。这就牵扯到密码学的RSA加密算法<del>在前面输入指令中出现过</del>。简单来说公钥是可公开信息，而私钥是你自己保管。通过一系列算法保证信息安全性。因为对极大整数做因数分解的难度决定了RSA算法的可靠性（不是简单入门的素数判断哦）穷举可破解，但时间得不偿失😊。</li><li>②描述：在hexo文件夹中，找到_config.yml文件并修改时需要注意的事项。<br>  第一这类文件对格式要求即为严格，<font color="#DC143C"> 每个冒号后必须要使用一个空格 </font>，对它的修改在后来配置自己博客时经常出现，所以需要牢记。不然本地检测会报错。<br><img src="\images\error.jpg" alt="错误实例" title="从朋友那爬了一张图"><br>  第二修改时会有一项<code>repository:</code>     注意使用的是github上项目的SSH不是HTTP！不是HTTP！<del>没有第三遍</del></li></ul></blockquote><p>至此基本总结结束，后续也许会修改</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下为本博客创建时所遇到的一些疑难问题与所关注过的注意事项，对其有详细解答。中途还会介绍涉及到的部分零碎知识。如有描述不准，望海涵斧正。&lt;a href=&quot;https://www.cnblogs.com/fengxiongZz/p/7707219.html&quot; target=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>First post</title>
    <link href="http://yoursite.com/2018/12/30/First%20post/"/>
    <id>http://yoursite.com/2018/12/30/First post/</id>
    <published>2018-12-30T05:32:01.000Z</published>
    <updated>2018-12-30T08:21:35.231Z</updated>
    
    <content type="html"><![CDATA[<p> I konw it seems like the world is crumbling out there,but it is actually a great time in your life to get a little crazy.Follow your curiosity,and be ambitious about it.Don’t give up your dreams. The world needs you all!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; I konw it seems like the world is crumbling out there,but it is actually a great time in your life to get a little crazy.Follow your cur
      
    
    </summary>
    
    
  </entry>
  
</feed>
